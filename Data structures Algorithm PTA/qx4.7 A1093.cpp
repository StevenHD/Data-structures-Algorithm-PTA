//A1093. 有几个PAT
//------方法和技巧------
// 活用递推

//-------题意--------
// 给定一个字符串，问一共可以形成多少个PAT？

//-------思路--------
// 直接暴力求解会超时
// 换个角度思考问题，对一个确定了位置的A来说，以它形成的PTA的个数等于它左边P的个数
// 乘以它右边T的个数。例如对字符串APPAPT的中间那个A来说，它左边有2个P，右边有1个T，
// 所以这个A能形成的PAT的个数就是2×1=2(个)
// 于是问题就转换为：对字符串中的每个A，计算它左边P的个数与它右边T的个数的乘积，然后把所有A的这个乘积相加
// 最后所得 和 就是答案

// 那么是否有比较快地获得 每一位左边P的个数 的方法呢？当然有，只需要开一个数组leftNumP
// 这个数组leftNumP记录每一位左边P的个数(含当前位，下同)。接着从左到右遍历字符串
// 如果当前位i是P，那么leftNumP[i]就等于leftNumP[i-1]加1；
// 如果当前位i不是P，那么leftNumP[i]的大小就等于leftNumP[i-1]的大小；
// 于是只需要O(length)的时度就能统计出leftNumP数组

// 每一位右边T的个数 的计算方法也是同样的，为了减少代码量，不妨在统计每一位右边T的个数的过程中
// 直接计算答案ans。
// 具体做法是：定义一个变量rightNumT，用以记录当前累计右边T的个数。从右往左遍历字符串，
// 如果当前位i是T，那么令rightNumT加1；
// 否则，如果当前位i是A，那么令ans加上leftNumP[i]与rightNumT的乘积(注意取模)
// 这样，当遍历完字符串时，就得到了答案ans


//-------注意点-------
// C1：采用 分别遍历P A T的位置来统计的方法相当于暴力解法，会超时
// C2：记得取模
// C3：这道题与PAT B1045/A1101的思路很像，认真体会和对比这两道题的思想




//----------CODE----------
#include "C.h"

const int maxn = 100010;
const int mod = 1000000007;

//---定义字符串---
char str[maxn];
//---每一位左边(含)P的个数
int leftNumP[maxn] = { 0 }; //为什么不把rightNumT[]数组定义成全局的

int main()
{
	//---读入字符串---
	gets_s(str);
	//---长度---
	int len = strlen(str);

	//----从左到右遍历字符串-----
	for (int i = 0; i < len; i++)
	{
		//---如果不是0号位---
		//---继承上一位的结果---
		if (i > 0)
		{
			leftNumP[i] = leftNumP[i - 1];
		} // leftNumP[]中存放的就是P的个数，个数的增加看得是下面呢个if{}

		//---如果当前位是P---
		//---令leftNumP[i]加1---
		if (str[i] == 'P')
		{
			leftNumP[i]++;
		}
	}

	//---ans为答案，也就是有多少个PAT，rightNumT记录右边T的个数---
	int ans = 0;
	int rightNumT = 0; // 为什么leftNUmP定义成全局的，rightNumT定义成局部的？

	//----从右到左遍历字符串----
	for (int j = len - 1; j >= 0; j--)
	{
		//---如果当前位是T---
		//---右边T的个数加1---
		if (str[j] == 'T')
		{
			/*rightNumT[j]++;*/
			rightNumT++; // 为什么右边T的个数是个int变量整数，leftNumP[]则是数组？
		}

		//---如果当前位是A---
		//---则累计乘积---
		else if (str[j] == 'A')
		{
			ans = (ans + leftNumP[j] * rightNumT) % mod; // 为什么要取模？
		}
	}

	printf("%d\n", ans);
	return 0;
}

//------疑问------
// 为啥LeftNumP是全局数组，rightNumT则是局部变量？因为时间复杂度吗？
// 也许是因为为了减少代码量，在统计T个数的时候直接计算答案ans
// 因为我们已经确定了A和P，所以从右往左找T的时候，就很方便，A又是定的，P也计算好了
// 所以没必要开一个数组来存储，变量即可，全局变量和局部变量在这里无所谓

// 为啥要取模？
// 没找到答案。。。
// 我的猜测是 一个小的正整数对一个超级大的正整数取余 结果还是小的正整数本身
// 只是为了防止万一出现太大的数导致内存放不下，报错，所以取余让这个意外出现的大数变小些

// 为什么到了T的时候，不用判断str[j]是否大于0位了，是因为j是从n-1开始的吗？
// 因为确定P的时候，是第一个确定的字母，从左往右，会碰到这个字母不是P的情况，这时候统计个数要进行
// 甄别，所以要判断是否是0号位，而且因为指标不断地向右移，但是不代表P的个数就一一对应的增大
// 所以要不断地以 前值 覆盖 新值，如果符合了要求，再 加1 更新 P 的数量