// B1029/A1084.  旧键盘

//-------CODE-------

#include "C.h"

int main() 
{
	char str1[100], str2[100];

	//---hashTable数组用来标记字符是否已被输出---
	bool HashTable[128] = { false };

	gets_s(str1);
	gets_s(str2);

	int len1 = strlen(str1);
	int len2 = strlen(str2);

	//---枚举第一个字符串中的每个字符---
	for (int i = 0; i < len1; i++) 
	{
		int j;
		char c1, c2;

		//---枚举第二个字符串中的每个字符---
		for (j = 0; j < len2; j++) 
		{
			c1 = str1[i];
			c2 = str2[j];

			//---如果是小写字母，则转化为大写---
			if (c1 >= 'a' && c1 <= 'z') 
				c1 -= 32;

			if (c2 >= 'a' && c2 <= 'z') 
				c2 -= 32;

			//---如果c1在第二个字符串中出现，则跳出---
			//---跳出当前这个第二层for循环，进行if判断---
			if (c1 == c2) 
				break;
		}

		//---在第二个字符串中未出现c1，且c1未被输出过---
		if (j == len2 && HashTable[c1] == false)  // 这个if就是为了保证，相同的字符只出现一次！
		{
			printf("%c", c1);
			HashTable[c1] = true;
		}
	}

	return 0;
}

//------逻辑描述-------
// 第一遍中，第一层循环的第一个字符串，c1是第一个字符，7
// 第二层循环的第一个字符串是_，也就是c2是_
// 因为7和_不相等，所以不断增加j，在第二个字符串中寻找一个字符c2可以和c1相等
// 但是没有找到，这个时候，也就是当第二个字符串遍历完的时候，j=len
// c1一直没有匹配在第二个字符串中，c1也没有被输出，HT[c1]=false，所以print c1。
// 也就是说第一字符串和第二字符串中，c1和c2相等的时候，会break，跳出当前循环，也就是跳出第二层循环
// 因为如果是跳出最外层循环，就直接return 0了，那程序就结束了，所以是仅仅跳出第二层循环。
// c1=c2时，就不用管，相当于该键没有坏掉
// break后，j又不会等于len（大概率），所以就只是j++,进入下一次迭代。